# 核心逻辑

## 1. 项目要解决的问题
这个项目用“依赖图”的方式回答一个核心问题：**在一个 Vue/React 组件内部，哪些变量/函数彼此关联、被谁驱动、哪些是孤立/冗余/高耦合点**，从而为“拆文件 / 抽 composable（Vue）/ 抽 hook（React）”提供依据。

它把组件内的关键符号抽成**节点（TypedNode）**，把“在实现里引用/赋值/调用”抽成**有向边（A 依赖 B）**，并结合模板/样式的“是否使用”标记，生成重构建议与可视化输出。

## 2. 核心数据结构
- 节点：`TypedNode`，包含 `label`（变量/函数名）、`type`（`var`/`fun`）以及可选 `info`（行列号、注释、被哪些 hook/生命周期使用等），定义在 `packages/core/src/analyze/utils.ts:4`。
- 边：从节点 A 指向节点 B，表示“**A 的实现依赖 B**”，并附带 `RelationType`：`get`/`set`/`call`，定义在 `packages/core/src/analyze/utils.ts:26`，判定逻辑在 `packages/core/src/analyze/utils.ts:216`。
- 图：`{ nodes: Set<TypedNode>, edges: Map<TypedNode, Set<{ node: TypedNode, type: RelationType }>> }`，由 `NodeCollection.map()` 把内部 string 图映射成 TypedNode 图，见 `packages/core/src/analyze/utils.ts:118`。
- 使用集合：
  - `nodesUsedInTemplate`：模板/JSX 中实际使用到的标识符集合
  - `nodesUsedInStyle`：`<style>` 中 `v-bind()` 使用的变量集合（Vue）

## 3. 分析总流程（从源码到建议）
### 3.1 Vue（SFC）
典型调用方（VSCode 扩展）流程在 `packages/vscode/src/analyze.ts:17`：
1) 用 `@vue/compiler-sfc` 的 `parse` 解析 SFC，见 `packages/core/src/index.ts:7`、调用处 `packages/vscode/src/analyze.ts:26`。
2) 分析脚本：
   - 若存在 `<script setup>`：走 `analyzeSetupScript()`，见 `packages/vscode/src/analyze.ts:28`，核心实现是 `packages/core/src/analyze/setupScript.ts:815`。
   - 否则 `<script>`（Options API）：走 `analyzeOptions()`，见 `packages/vscode/src/analyze.ts:35`，核心实现是 `packages/core/src/analyze/options.ts:30`。
   - 兼容“整文件就是 options 对象/TSX”的兜底路径，见 `packages/vscode/src/analyze.ts:44`。
3) 分析模板：`analyzeTemplate()` 将 template 编译为 render code，再从 `_ctx.xxx` 收集使用到的节点，见 `packages/core/src/analyze/template.ts:8`、调用处 `packages/vscode/src/analyze.ts:60`。
4) 分析样式：`analyzeStyle()` 从 style 内容里解析 `v-bind(...)` 变量，见 `packages/core/src/analyze/style.ts:65`、调用处 `packages/vscode/src/analyze.ts:68`。
5) 生成建议与可视化：
   - 建议：`gen()`，见 `packages/core/src/suggest/index.ts:19`。
   - Mermaid：`getMermaidText()`，见 `packages/core/src/mermaid.ts:7`。
   - Vis-network 数据：`getVisData()`，见 `packages/core/src/vis.ts:16`。

### 3.2 React（JSX/TSX）
React 的入口统一走 `analyzeTsx()`，见 `packages/vscode/src/analyze.ts:76`，核心实现是 `packages/core/src/analyze/tsx.ts:495`：
- 它用 `babelParse`（开启 `typescript` + `jsx`）生成 AST，见 `packages/core/src/analyze/tsx.ts:501`。
- 只分析 `export default` 的组件形态：
  - `export default function ...` / `export default () => {}`：分析函数体 BlockStatement
  - `export default class ...`：分析 `render()` 方法体
 见 `packages/core/src/analyze/tsx.ts:418`。
- `nodesUsedInTemplate` 来自“return JSX”里出现的标识符，见 `packages/core/src/analyze/tsx.ts:340`。

## 4. 脚本分析的核心：构建“组件内依赖图”
### 4.1 Vue Options API：`analyze/options.ts`
`analyze()` 会：
- 收集节点：
  - `data()` 返回对象的属性名 -> 变量节点，见 `packages/core/src/analyze/options.ts:69`。
  - `computed` 下的 key -> 计算属性节点（标记 `isComputed`），见 `packages/core/src/analyze/options.ts:105`。
  - `methods` 下的 key -> 方法节点（标记 `isMethod`），见 `packages/core/src/analyze/options.ts:128`。
- 收集边：
  - 在 computed/methods 的实现里扫描 `this.xxx`，把 `xxx` 加入边，见 `packages/core/src/analyze/options.ts:441`、`packages/core/src/analyze/options.ts:491`。
  - 对 `watch` 之类的 hook（含 `watchHooks` 与生命周期）标记“哪些节点被 hook 使用”，并为 watch 回调中涉及的其它 `this.xxx` 生成依赖边，见 `packages/core/src/analyze/options.ts:516`。
- 识别“模板使用”：
  - 如果组件有 `render()`：从 `return` 的 JSX/表达式里抓 `this.xxx`，见 `packages/core/src/analyze/options.ts:151`、`packages/core/src/analyze/options.ts:377`。
  - 如果组件有 `setup()` 且返回 render 函数：扫描返回函数体里出现的标识符，见 `packages/core/src/analyze/options.ts:216`。

### 4.2 Vue `<script setup>` / 组合式：`analyze/setupScript.ts`
核心是 `processSetup()`（`packages/core/src/analyze/setupScript.ts:31`），分两步：
- 收集节点：只把顶层（`Program`）或 `setup` 方法体顶层的变量/函数声明作为节点（避免把内部临时变量当成节点），见 `packages/core/src/analyze/setupScript.ts:48`、`packages/core/src/analyze/setupScript.ts:236`。
- 收集边：在函数体/初始化表达式里遍历 Identifier，把同一根作用域下的引用变成边，见 `packages/core/src/analyze/setupScript.ts:449` 之后的多个分支。

同时它对“hook 的语义”做了额外处理（用于标记使用与补边）：
- Vue `watch*`（以及 `watchEffect`）与 React `useEffect`（第二参数为依赖数组）会把依赖项当成“watchArg”，把回调中引用到的其它节点补成边，见 `packages/core/src/analyze/setupScript.ts:323`、`packages/core/src/analyze/setupScript.ts:354`、`packages/core/src/analyze/setupScript.ts:420`。
- `provide()` 会把参与 `provide` 的节点标记为 used，见 `packages/core/src/analyze/setupScript.ts:295`。

### 4.3 Vue TSX 与 React：`analyze/tsx.ts` + `utils/traverse.ts`
`processTsx()`（`packages/core/src/analyze/tsx.ts:393`）把两类场景统一为“在某个 BlockStatement / setup 范围内”：
- 先收集节点（变量声明/函数声明），再收集 return JSX 使用节点，最后收集边，见 `packages/core/src/analyze/tsx.ts:308`、`packages/core/src/analyze/tsx.ts:340`、`packages/core/src/analyze/tsx.ts:352`。
- 解析细节由 `packages/core/src/utils/traverse.ts` 提供一组“模式解析器”（Identifier/ObjectPattern/ArrayPattern 等），实现“声明-引用-边”的统一处理。

## 5. 建议生成的核心：图算法 + 规则组合
`gen()`（`packages/core/src/suggest/index.ts:19`）把图切分成若干子图后，对每个子图执行启发式规则：
- 多子图场景：识别“孤立节点群”，建议拆成独立文件，见 `packages/core/src/suggest/index.ts:38`。
- 未使用节点：结合 `nodesUsedInTemplate/style` 与 `node.info.used`（被 hook/生命周期引用）判定，见 `packages/core/src/suggest/index.ts:55`、`packages/core/src/suggest/index.ts:115`。
- 循环依赖（loop call）：`hasCycle()` 检测环，并且要求环上边类型均非 `get`（更偏向“调用/赋值循环”），见 `packages/core/src/suggest/utils.ts:3`。
- 线性链路（函数链式调用）：`findLinearPaths()` 找出长链并在“链中部分节点被模板使用”时给 warning，见 `packages/core/src/suggest/index.ts:77`。
- 关节点（articulation point）：对子图规模较大时计算关节点并提示重点关注，见 `packages/core/src/suggest/index.ts:98`、实现 `packages/core/src/suggest/filter.ts:172`。
