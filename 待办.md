# 待办

## P0（引入 IR：让分析可校验、可演进、可落地）
- 引入 IR（中间表示）层：在 `packages/core/src/analyze/*` 与 `packages/core/src/suggest/*` 之间增加稳定的 IR 协议，把当前“TypedNode 依赖图 + used 集合”的实现细节收敛为统一数据结构（节点唯一 ID、作用域、来源区块：script/template/style、引用类型 get/set/call、以及被哪些 hook/生命周期使用等），为后续“抽取方案生成/自动修复”提供可演进的接口。
- IR 作为唯一事实源：`suggest/vis/mermaid/eslint/vscode/mcp` 全部只消费 IR，不直接依赖 AST 遍历产物，避免不同调用方/不同 analyzer 的结果分叉。
- IR 的最小闭环：先把现有 `TypedNode` 与 `nodesUsedInTemplate/style` 迁移为 IR 字段，确保输出与现状一致，再逐步补齐 slot props、宏语义、更多导出形态等信息。
- 基于 IR 生成“重构方案”（核心方法）：用 IR 的依赖图与模板/样式绑定信息做分组、定边界、定接口、定顺序，输出可落地的计划（候选方案 + 风险/收益评分 + 迁移步骤）。
- IR 的方案生成管线：1) 识别候选团块（子图/连通分量/链路/环/关节点周边）2) 计算团块边界（对外依赖与对外暴露）3) 推导抽取接口（入参=外部依赖，返回=对外暴露）4) 选择抽取形态（Vue composable / React hook / 子组件 / service 模块）5) 产出可执行 steps（先断环/先抽纯函数/再抽副作用/最后搬 UI）。
- 图算法库化与选型：把 `splitGraph`/`hasCycle`/`findLinearPaths`/`findArticulationPoints` 等从 `core` 抽成独立的 `graph` 模块（甚至单独 package），并优先评估成熟 Node.js 图算法库来避免闭门造车与算法前提错误。
- 候选库调研清单：`graphology`（TS 友好且带标准算法库，适合做通用 Graph/算法底座，来源：<https://graphology.github.io/>），`@dagrejs/graphlib`（提供图结构与一组经典算法，如 `alg.tarjan`/`alg.findCycles`/`alg.isAcyclic`/`alg.topsort` 等，来源：<https://github.com/dagrejs/graphlib/wiki/API-Reference>、<https://www.npmjs.com/package/@dagrejs/graphlib>），`cytoscape.js`（内建 BFS/PageRank 等算法并偏可视化生态，来源：<https://js.cytoscape.org/>）；`js-graph-algorithms`（功能覆盖广但维护较久未更新，需谨慎，来源：<https://www.npmjs.com/package/js-graph-algorithms>）。

## P1（基于 IR 修正偏差：让结果更准）
- 节点唯一性升级：节点 key 不再仅用 `label` 去重（`packages/core/src/analyze/utils.ts:43`），引入稳定 ID（至少基于 `binding.identifier.start/end` 或 `scope + name`），否则同名会压扁图并连带影响“环/链/未使用”的正确性。
- 统一 `lineOffset` 契约：把 `<script setup>` 与 `<script>` 的 offset 规则做成“一个地方定义、所有调用方复用”，并修正 ESLint 与 VSCode 的不一致（`packages/vscode/src/analyze.ts:28` vs `packages/eslint/src/utils.ts:125`）。
- 建议协议稳定化：`Suggestion` 增加稳定 `code`（例如 `loop-call`/`not-used`/`isolated-group`/`linear-chain`），ESLint 按 `code` 匹配，避免 `message.includes(...)` 的脆弱耦合（`packages/eslint/src/rules/loop-call.ts:41`）。
- 收敛为 `core` 单一入口：把 `parse SFC -> analyze script -> analyze template/style -> gen` 固化成一个导出函数，VSCode/MCP/ESLint/Playground 只负责传参和展示，解决当前多处重复实现（如 `packages/vscode/src/analyze.ts:17`、`packages/mcp/src/analyze.ts:16`、`packages/eslint/src/utils.ts:110`）。
- 修复 ESLint report 定位：避免 `loc.start/end` 反向导致高亮异常（如 `packages/eslint/src/rules/loop-call.ts:51-55`）。
- Template used 集合降噪：目前 `analyzeTemplate()` 会把 `ref` 字符串、`_resolveComponent` 的字符串参数也当成“使用节点”（`packages/core/src/analyze/template.ts:37`、`packages/core/src/analyze/template.ts:48`），需要分类型输出或过滤策略，避免 used 集合误导建议。

## P2（提升覆盖面：让更多真实项目“有图且图完整”）
- React 组件识别增强：补齐常见导出形态（`export default Comp`、`memo/forwardRef` 包装、命名导出），目前 `analyzeTsx()` 主要从 `ExportDefaultDeclaration` 里找组件（`packages/core/src/analyze/tsx.ts:418`）。
- Vue `<script setup>` 宏语义补全：对 `defineProps/defineEmits/withDefaults` 等宏至少做到“不要污染节点收集/不要误判未使用”（当前仅做 ignore，`packages/core/src/analyze/setupScript.ts:12`）。
- Vue TSX / setup-return-render 场景一致化：Options API 的 `setup()` 与 TSX 分析走的是不同实现路径（`packages/core/src/analyze/options.ts` vs `packages/core/src/analyze/tsx.ts`），需要明确优先级与一致的“使用节点/图构建”语义。

## P3（提升建议质量：从“图提示”走向“可执行重构方案”）
- 建议分层：在 `Suggestion` 里加入 `confidence`/`risk`/`nextSteps`，避免所有建议都停留在“perhaps you can refactor it”层面（`packages/core/src/suggest/index.ts:19`）。
- “可抽取子图”生成：在 `splitGraph()` 的基础上，把子图与 `usedNodes` 交叉，优先产出“与模板强相关的一组 + 纯内部逻辑的一组”，用于拆文件/抽 composable 的候选对象（`packages/core/src/suggest/split.ts:44`、`packages/core/src/suggest/index.ts:34`）。
- 抽取接口建议：对候选子图做“外部依赖扫描”（子图内节点引用但不在子图内的节点集合），直接给出 composable/hook 的入参/返回值建议。
- 基于 IR 做跨框架一致的“抽取建议”：把 Vue composable 与 React hook 的抽取判断统一落在 IR 上（外部依赖集合、模板/JSX 绑定集合、副作用集合），避免建议逻辑散落在不同 analyzer/调用方里。

## P4（图算法与性能：为大文件/全仓使用做准备）
- 校准“关节点”算法前提：当前依赖图是有向图，但 `findArticulationPoints()` 使用的是经典关节点思路（`packages/core/src/suggest/filter.ts:172`），需要明确是否要转无向后计算，或引入更适合有向依赖图的“关键节点”指标。
- 优化连通分量切分：`splitGraph()` 目前通过重复 DFS + 交集合并的方式切分（`packages/core/src/suggest/split.ts:51`、`packages/core/src/suggest/split.ts:28`），可替换为一次性标准算法以减少重复遍历并稳定结果。
- 缓存与复用：同一份 AST/模板编译产物在多个输出（vis/mermaid/suggest）里复用，避免重复 parse/compile。
