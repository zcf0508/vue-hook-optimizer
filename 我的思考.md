# 我的思考（未读代码前的重构设想）

## 0. 我对项目的第一性假设
我假设这个项目的本质是：对 Vue SFC / React 组件进行静态分析（AST + 规则系统），输出可操作的重构建议（拆文件、抽 hook、抽 composable、降复杂度、统一模式），并尽量做到：
- 建议可定位：能精确到文件/行/节点范围
- 建议可解释：说明为什么是问题、风险是什么、收益是什么
- 建议可落地：给出可执行的改法（甚至生成 patch）
- 支持渐进式：可扩展规则、可配置、可插拔

在不读代码的前提下，我认为该类工具最容易“能跑但不好用”，问题通常出在：规则无法沉淀复用、输出不可操作、误报漏报高、性能差、架构难扩展、Vue/React 差异没抽象出来。

---

## 1. 我期望的“核心分析流水线”长什么样
无论 Vue 还是 React，我都倾向于把流程统一抽象为五段，并且每段都能单测：

1) **Parse（解析）**
- 输入：文件内容 + 语言配置（TS/JS/JSX/TSX/Vue SFC）
- 输出：统一的 AST 表达 + 源码位置信息（range/loc）+ 语法错误容错信息
关键点：Vue SFC 需要把 template/script/style 分开解析，script 可能是 `<script setup>` 或 options API。

2) **Normalize（归一化/建模）**
- 将不同框架的“组件概念”统一成一个中间模型（IR），比如：
  - `ComponentModel`: props、emits、state、computed、watch、effects、methods、render/template、imports、exports
  - `DependencyGraph`: 变量/函数/模板引用关系、hook/composable 调用关系
  - `ScopeGraph`: 作用域与闭包捕获（对 hook 抽取很关键）
- Vue Options API、Vue Composition API、React Hooks：最终都落在“响应式状态 + 派生 + 副作用 + 事件处理 + 视图绑定”的同一套概念上。

3) **Measure（度量）**
- 复杂度不是只有圈复杂度，我会把度量分层：
  - 文件级：LOC、导入数量、导出数量、顶层声明数
  - 组件级：state 数量、computed 数量、watch 数量、effect 数量、事件处理数量
  - 视图级：template/JSX 结构深度、条件分支数、列表渲染层数、slot/children 复杂度
  - 耦合级：跨模块引用密度、同文件内“逻辑团块”相互引用比例
- 度量输出要能被规则消费（Rule 读取 metric，而不是重复计算）

4) **Rule Engine（规则引擎）**
- 规则要尽量“声明式 + 可配置 + 可解释”，避免把规则写成一堆 if-else。
- 规则输出统一为 `Finding`：
  - `id`, `title`, `severity`, `message`, `location`, `suggestedFix`, `tags`, `confidence`
- 强烈建议引入 `confidence`（置信度），静态分析天然不完美；低置信度的建议要弱提示或需要人工确认。

5) **Report（报告/呈现）**
- 输出不仅是文本，还应包含结构化 JSON（给 IDE 插件 / CI 使用）
- 支持“按组件/按规则/按文件/按收益”排序
- 最好能生成“重构计划”：先做低风险高收益，再做高风险项

---

## 2. 我会如何系统化“拆文件”与“抽 hook/composable”
### 2.1 拆文件：从“逻辑团块（cohesive chunks）”切
拆文件不是按行数切，而是按“高内聚、低耦合”的逻辑团块切。团块识别可以来自：
- import/export 边界（天然模块边界）
- 同一组 state/computed/watch 共同服务于某一块 UI（通过模板/JSX 引用反推）
- 同一组 handler 共同服务于某一类交互（比如表格分页/筛选/排序）
- API 调用与其派生状态/错误/loading/重试逻辑（典型可抽为 composable/hook）

我会把“拆分建议”表达成候选方案，而不是唯一答案：
- 方案 A：抽 `useTableQuery`（包含 query、fetch、分页、缓存）
- 方案 B：抽 `TableToolbar.vue` + `TableBody.vue`（拆 UI）
- 方案 C：把 domain 逻辑移到 `services/` 或 `domain/`（拆业务层）

并给出每个方案的收益/风险/代价评分（可启发式）。

### 2.2 抽 hook/composable：用“闭包捕获 + 副作用边界”判定
能否抽取，核心看三点：
- **输入/输出是否可参数化**：依赖是否能通过参数传入（props、store、router、api client）
- **闭包捕获是否可控**：捕获太多外部变量，抽了也不独立；需要通过参数或返回值重构
- **副作用是否有清晰边界**：effect/watch/onMounted 的生命周期与清理是否能封装

在 React 场景，我会重点抓：
- 自定义 hook 里是否违反 Rules of Hooks（条件调用、循环调用）
- effect 依赖数组问题（缺依赖/多依赖/函数稳定性）
- “数据获取 + 状态机”是否可抽 `useRequest`/`useAsync`

在 Vue Composition API 场景，我会重点抓：
- `watch`/`watchEffect` 是否过度、依赖是否隐式
- `computed` 是否包含副作用
- `ref/reactive` 是否混乱导致解构丢响应
- 典型可抽：`usePagination`、`useForm`、`useDialog`、`usePermission`、`useDebouncedRef`

在 Options API 场景，我会重点抓：
- methods 与 data/computed/watch 是否形成“功能簇”
- mixin 的可替代方案（组合式函数、插件）
- 大量 this.xxx 访问导致耦合高（迁移到 composition 时的切入点）

---

## 3. 我会怎么把 Vue 与 React 的差异“消化掉”
我倾向于做两层抽象：

- **Framework Adapter（框架适配层）**
  - VueAdapter：解析 SFC、识别 options/composition、提取 template 引用
  - ReactAdapter：解析 JSX、识别 function component/class component、提取 hooks 调用图

- **Core Analyzer（核心分析层）**
  - 只依赖 IR，不关心 Vue/React 细节
  - 规则优先写成 IR 规则：如“派生状态冗余”“副作用过多”“逻辑团块耦合过强”

这样新增 Svelte/Angular 或者支持更多语法时，不至于规则全重写。

---

## 4. 我预期该项目最可能出现的“结构性问题”（我会带着这些去读代码）
> 这部分是我读代码时的检查清单，后续会用事实逐条对照。

### 4.1 规则体系不可复用
- 规则写死在遍历 AST 的过程中，导致新增规则要改核心代码
- 缺少统一 `Finding` 模型，输出难以组合、难以排序

### 4.2 Vue SFC 解析不完整
- `<script setup>`、`defineProps/defineEmits`、宏、TS 类型只做了字符串层面的处理
- template 与 script 的引用没打通（导致拆分建议无法基于 UI 关联）

### 4.3 React hook 分析停留在“字符串匹配”
- 没做调用图、没做 scope/capture，抽 hook 建议只能泛泛而谈
- 对 effect 依赖分析缺失（依赖数组、稳定性、memo/callback）

### 4.4 性能与可扩展性问题
- 对每个规则重复 parse / traverse（应缓存 AST/IR）
- 大文件/全仓扫描无增量机制（没有基于文件 hash 的缓存）

### 4.5 工程化不足导致“建议不可落地”
- 没有 fix-it（自动生成 patch 或至少给出明确代码片段）
- 缺少置信度与风险提示，用户不敢用

---

## 5. 如果让我重构，我会优先做的架构调整（不涉及具体实现细节）
按收益优先级（高 → 低）：

1) **统一 IR + Finding 模型**
- 一次解析，多规则复用
- 把“分析”与“呈现”分离，CLI/IDE/CI 都能用

2) **规则引擎插件化**
- 核心只管：加载规则、提供 IR、收集 Findings
- 规则只关心：输入 IR、输出 Findings
- 支持规则分组与配置（阈值、黑白名单、忽略路径）

3) **建立引用关系图（Template/JSX ↔ Script）**
- 拆文件与抽 hook 的质量，80% 取决于引用关系是否准确

4) **输出改为“计划 + 方案”而不是单点建议**
- 对拆分这种非唯一答案的问题，输出多个候选，并给评分与风险

5) **增量分析与缓存**
- 全仓扫描必须支持缓存，否则体验会很差

---

## 6. 我会如何定义“这个项目的护城河”
如果要把它做成同类中强的，我认为护城河在三点：
- **高质量 IR**：把 Vue/React 的复杂语法差异吞掉，形成稳定分析接口
- **可落地的建议**：定位准、解释清、可自动修复或半自动生成 patch
- **规则资产沉淀**：规则可复用、可配置、可组合，形成长期迭代的资产库

---

## 7. 我接下来读代码时的行动路径（用于后续步骤）
- 先找入口：CLI/主流程/分析管线在哪里
- 再找解析层：Vue SFC 与 React AST 如何生成与缓存
- 再找建模层：是否存在中间模型或直接在 AST 上做规则
- 再找规则集：规则组织方式、可配置性、输出结构
- 最后看输出：报告格式、定位能力、是否有 fix

（以上是我在不读代码前的重构设想，后续会用代码事实校正。）

---

## 8. 读码后的校正：我的预期 vs 代码事实
### 8.1 实际核心模型不是 IR，而是“组件内符号依赖图”
我原本预期会有一层较明确的 IR（ComponentModel/ScopeGraph/DependencyGraph）。读码后发现当前落地是更轻量的模型：
- 节点：`TypedNode`（`label` + `var/fun` + `info`），见 `packages/core/src/analyze/utils.ts:4`
- 图：`NodeCollection.map()` 把内部 string 图映射成 typed 图，见 `packages/core/src/analyze/utils.ts:118`
- 依赖边：用 `get/set/call` 三分类表达“引用/写入/调用”，见 `packages/core/src/analyze/utils.ts:216`

这套模型足够支撑“孤立节点 / 未使用 / 链路 / 环”等一阶建议，但要做到我在第 2 节里提到的“可抽取的逻辑团块 + 接口建议”，还缺少“跨 template/script 的更强引用关系”和“外部依赖边界”的建模。

### 8.2 Vue/React 适配层是存在的，但以“多入口函数”分散实现
我原本设想 Adapter 层会集中在一个入口。实际是：
- Vue options API：`packages/core/src/analyze/options.ts`
- Vue `<script setup>`：`packages/core/src/analyze/setupScript.ts`
- Vue TSX 与 React TSX：`packages/core/src/analyze/tsx.ts`
- Vue template/style 的 used 集合：`packages/core/src/analyze/template.ts`、`packages/core/src/analyze/style.ts`

而把这些拼起来的“完整分析流程”目前散落在多个包的调用方（VSCode/MCP/ESLint/Playground），例如 VSCode 的总流程在 `packages/vscode/src/analyze.ts:17`。这与我预期的“core 统一入口、调用方变薄”不一致，也直接影响后续迭代成本与一致性。

### 8.3 “模板使用识别”走的是编译产物启发式
我原本预期 template/script 引用会被打通成统一图关系。实际：
- template 用 `compileTemplate()` 编译后从 `_ctx.xxx` 抽取使用集合（`packages/core/src/analyze/template.ts:12`）
- script 侧再用 used 集合去影响建议生成（`packages/core/src/suggest/index.ts:34`）

这条路径的优势是工程上简单、可快速覆盖大量场景；劣势是 used 集合会引入噪声（组件名、ref 字符串等）且对复杂语义存在误差，因此更像“启发式指标”而不是“严谨引用关系”。

### 8.4 建议引擎目前是“图算法 + 少量规则”，而非 Finding 体系
我原本主张统一 Finding 模型（id/置信度/风险/可执行修复）。实际 `gen()` 输出的 `Suggestion` 只有 `type/message/nodeInfo`，见 `packages/core/src/suggest/index.ts:13`。

ESLint 规则还依赖 `message.includes(...)` 来识别建议类型，见 `packages/eslint/src/rules/loop-call.ts:41`。这会导致规则与文案耦合，后续如果做国际化/改文案会破坏行为。

### 8.5 我对“待办”的校正方式
基于以上事实，我的待办不应停留在抽象层面的“做 IR/做插件化”，而应优先解决：
- 调用链重复与行为分叉（统一入口）
- 定位一致性（lineOffset 统一）
- 节点唯一性（同名冲突）
- 规则输出协议稳定性（从 message 走向 code/id）

这些会直接提升工具的可信度与扩展速度，并为后续“生成可执行重构方案”打底。
