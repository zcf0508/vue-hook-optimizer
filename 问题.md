# 问题

## 1. 架构层：同一分析流程在多处重复实现
Vue/React 的“解析 SFC -> 分析 script -> 分析 template/style -> 生成建议”在多个包里重复一份：
- VSCode 扩展：`packages/vscode/src/analyze.ts:17`
- MCP server：`packages/mcp/src/analyze.ts:16`
- ESLint 插件：`packages/eslint/src/utils.ts:110`
- Playground server：`packages/playground/server/api/analyze.ts`（同样的调用链）

结果是：
- 修一个 bug 要改多处，容易出现行为不一致
- 无法沉淀为 `core` 层的单一入口（比如 `analyzeFile(code, framework)`）

## 2. 定位层：行号 offset 计算存在不一致/可疑点
同一逻辑在不同包里对 line offset 的处理不一致，容易导致 VSCode/ESLint 上定位对不上：
- VSCode 对 `<script setup>` 使用 `(loc.start.line || 1) - 1`，见 `packages/vscode/src/analyze.ts:28-33`。
- ESLint 对 `<script setup>` 使用 `loc.start.line || 0`（没有 `-1`），见 `packages/eslint/src/utils.ts:125-130`。

这会直接影响：
- `TypedNode.info.line/column` 与 ESLint AST 节点 `loc` 的对齐
- ESLint 规则依赖“行列号匹配”时的命中率（会漏报/错报）

另外，`loop-call` 规则里 report 的 `loc` start/end 位置是反的（start 用了 `node.loc.end`），见 `packages/eslint/src/rules/loop-call.ts:51-55`，这会导致高亮范围异常。

## 3. 语义层：节点以 `label` 去重，天然存在同名冲突
`NodeCollection.addNode()` 在 `label` 已存在时直接返回，见 `packages/core/src/analyze/utils.ts:43-45`。

这意味着：
- **不同作用域的同名变量/函数会被合并**（即使逻辑上是不同实体）
- Vue Options API 里不同分支/闭包里同名声明、React 组件里局部 shadowing，都可能把图“压扁”
- 进一步影响建议：误判为环、误判为长链、误判为未使用

当前分析确实尝试用 `binding.scope` 来限制“只收集根作用域节点”，但只要“根作用域内有同名”，冲突仍不可避免；而 TS/JS 里同名在不同声明形态/不同块级也并不罕见。

## 4. 分析覆盖面：对 Vue/React 的常见形态支持不完整
### 4.1 React 组件形态覆盖偏窄
`analyzeTsx()` 主要从 `ExportDefaultDeclaration` 里找组件，见 `packages/core/src/analyze/tsx.ts:418`。

对真实项目里常见的形态支持不足，例如：
- `export default memo(function Comp(){})`
- `const Comp = () => ...; export default Comp`
- `export function Comp() {}`（命名导出）

这会导致分析“跑了但没有图/图不完整”，从而让用户对工具失去信任。

### 4.2 Vue `<template>` 使用节点识别是“编译产物启发式”
`analyzeTemplate()` 通过 `compileTemplate()` 把模板编译成 render code，再匹配 `_ctx.xxx`，见 `packages/core/src/analyze/template.ts:12`、`packages/core/src/analyze/template.ts:27`。

优点是实现简单；但缺点是：
- 对某些复杂模板语义（slot props、解构、动态组件/指令参数）可能出现漏报或误报
- “组件名/`ref` 字符串”等也被当作节点名加入集合（`packages/core/src/analyze/template.ts:37`、`packages/core/src/analyze/template.ts:48`），而脚本图里往往没有对应节点，会造成 used 集合噪声

### 4.3 `<style>` 只支持 `v-bind()` 的抽取
`analyzeStyle()` 仅通过正则扫描 `v-bind(...)`，见 `packages/core/src/analyze/style.ts:63-85`，不覆盖其它风格（如 CSS Modules、`var(--xxx)` 间接绑定等）。

## 5. 图算法与建议规则：部分算法前提与当前图模型不匹配
### 5.1 “关节点（Articulation Point）”算法用在有向图上可疑
`findArticulationPoints()` 采用经典 Tarjan 风格的关节点算法，见 `packages/core/src/suggest/filter.ts:172`。

但当前 `edges` 是“依赖有向边”（A -> B），在有向图上直接套用无向关节点算法会产生概念偏差：
- 可能把“出度高的工具函数”误判为关节点
- 或错过真正的“职责缠结点”（尤其是回边/双向依赖较多时）

### 5.2 子图切分实现存在重复遍历与非典型写法
`splitGraph()` 每次遍历一个起点都会新建 `visited`，见 `packages/core/src/suggest/split.ts:51-57`，然后再靠 `mergeSets()` 通过集合交集做合并，见 `packages/core/src/suggest/split.ts:28`。

这会带来：
- 不必要的重复 DFS（性能与可预测性变差）
- 组件划分结果更依赖遍历顺序与后续 merge 的副作用

## 6. 规则工程化：ESLint 规则依赖“字符串包含”判断类型
例如 `loop-call` 规则通过 `s.message.includes('There is a loop call')` 来判断建议类型，见 `packages/eslint/src/rules/loop-call.ts:41-42`。

这会导致：
- 只要文案变化/国际化，规则就失效
- 无法对建议做版本化与稳定协议（缺少 `id/code`）

## 7. 产出层：建议可读但不够“可执行”
目前建议主要是：
- “节点群孤立 -> 建议拆文件”
- “不使用 -> 建议删除”
- “线性链/环 -> 建议重构”

但缺少“下一步怎么改”的结构化信息：
- 没有候选拆分方案（按模板块/按业务域/按副作用边界）
- 没有提取 hook/composable 的接口建议（入参/返回值/依赖注入）
- 没有可选的自动修复/半自动 patch（即便只覆盖安全场景也能显著提升落地性）

