# 开发文档（IR + 图算法 + 重构方案生成，基于 graphology）

## 0. 目标与边界
### 0.1 目标
- 建立一个稳定、可演进、可校验的 **IR（Intermediate Representation，中间表示）**，作为唯一事实源。
- 基于 IR + 图算法生成“可落地”的重构方案：拆文件、抽 composable/hook、打断环、压平链路、删除未使用。
- 将图算法从 `packages/core` 中抽离为可复用的 Node.js 算法库（优先复用成熟图算法生态，避免闭门造车）。

### 0.2 非目标（本阶段不做）
- 不在本阶段直接做自动 code-mod（生成 patch）。IR 与方案生成先稳定，code-mod 作为后续阶段。
- 不引入运行时依赖 Vue/React 的执行环境，仍以静态分析为主。

## 1. 现状基线（用于“准确迁移”，不是推测）
当前 `core` 的数据基线是“符号依赖图 + used 集合”：
- 节点：`TypedNode`（`label`、`var/fun`、行列/注释/used 信息），`packages/core/src/analyze/utils.ts:4`。
- 边：`RelationType = get | set | call`，`packages/core/src/analyze/utils.ts:26`。
- 建议：`Suggestion` 仅包含 `type/message/nodeInfo`，`packages/core/src/suggest/index.ts:13`。
- 图算法（内置实现）主要包括：`splitGraph`、`hasCycle`、`findLinearPaths`、`findArticulationPoints`，分别在：
  - `packages/core/src/suggest/split.ts`
  - `packages/core/src/suggest/utils.ts`
  - `packages/core/src/suggest/filter.ts`

完整分析流程（parse SFC -> analyze script/template/style -> gen）目前分散在 VSCode/MCP/ESLint/Playground 调用方，典型实现见 `packages/vscode/src/analyze.ts:17`。

## 2. 技术选型：graphology 与标准库
### 2.1 Graph 数据结构：graphology
选择 `graphology` 作为底层 Graph 容器的理由：
- Graph 能表示 directed/undirected/mixed、支持自环与多重边等基础能力（对 IR 的演进友好）：
  - Graph 基础与 TS 支持说明见官方主页：<https://graphology.github.io/>。
- 提供 `mergeNode`/`mergeEdge` 等“幂等构建”能力（利于从 AST 多次遍历逐步补齐 IR）：
  - `mergeEdge` 的语义与返回 4 元组见 `Mutation` 文档：<https://graphology.github.io/mutation.html>。
- key 会被强制转字符串（IR 需要稳定 ID 时必须显式约束）：
  - `Design choices` 文档说明 key coercion：<https://graphology.github.io/design-choices.html>。

### 2.2 算法/工具库：按需引入标准库子包
graphology 的标准库提供了可直接复用的图算法与工具：
- 组件/连通分量：`graphology-components`（包含 `connectedComponents`、`stronglyConnectedComponents` 等）：
  - 文档：<https://graphology.github.io/standard-library/components.html>。
- DAG 相关：`graphology-dag`（包含 `hasCycle`、`topologicalSort` 等）：
  - 文档：<https://graphology.github.io/standard-library/dag.html>。
- 图算子：`graphology-operators`（包含 `subgraph`、`reverse`、`toDirected` 等）：
  - 文档：<https://graphology.github.io/standard-library/operators.html>。

标准库总览与 `graphology-library` 聚合包导入方式见：<https://graphology.github.io/standard-library/>。

结论：在本仓库里建议 **优先按需引入子包**（`graphology-components`/`graphology-dag`/`graphology-operators`），仅在需要时才引入聚合包 `graphology-library`，以控制体积与 tree-shaking 复杂度。

## 3. 模块与包的边界（目标架构）
> 这里给出“开发边界”，不涉及立即落地代码。

### 3.1 `packages/graph`（新增，算法库化）
职责：封装 graphology + 标准库算法，并提供一层“面向 IR 的图接口”，使上层不依赖 graphology 的细节。

对外导出建议：
- Graph 构建：`createDepGraph()`、`upsertNode()`、`mergeRelationEdge()`。
- 图查询：`getOutNeighbors()`、`getInNeighbors()`、`getEdgeRelations()`、`toAdjacency()`。
- 通用算法：`connectedComponents()`、`stronglyConnectedComponents()`、`hasCycle()`、`topologicalSort()`、`subgraph()`。
- VHO 特化算法：`findLinearChains()`、`findCutVerticesOnUndirectedProjection()`。

### 3.2 `packages/core`（改造为 IR 生产与方案生成）
职责：
- 解析/抽取：把 Vue/React 代码解析为 IR（唯一事实源）。
- 方案生成：基于 IR 与图算法生成 `RefactorPlan`（替代当前弱结构化 Suggestion）。
- 产物适配：为 VSCode/MCP/ESLint/Playground 输出各自需要的数据格式（vis/mermaid/eslint diagnostics）。

## 4. IR 数据结构设计（可序列化 + 可校验）
### 4.1 基本类型
```ts
export type Framework = 'vue' | 'react';
export type BlockKind = 'script' | 'template' | 'style';
export type LanguageKind = 'js' | 'ts' | 'jsx' | 'tsx' | 'vue';

export type RelationType = 'get' | 'set' | 'call';
export type NodeKind = 'var' | 'fun';

export type NodeId = string;
export type EdgeId = string;

export interface SourcePosition {
  line: number
  column: number
}

export interface SourceRange {
  start: SourcePosition
  end: SourcePosition
}

export interface SourceSpan {
  filePath?: string
  block: BlockKind
  range: SourceRange
  lineOffset: number
}
```

### 4.2 IRNode / IREdge（核心）
```ts
export interface IRNode {
  id: NodeId
  name: string
  kind: NodeKind
  framework: Framework
  declaredIn: SourceSpan
  comment?: string

  usedInTemplate: boolean
  usedInStyle: boolean
  usedBy: string[]

  tags: string[]
}

export interface IREdge {
  id: EdgeId
  from: NodeId
  to: NodeId

  relations: RelationType[]
  spans: SourceSpan[]
}
```

#### 4.2.1 NodeId 的生成原则（避免“同名压扁”）
必须满足：
- 同名不同实体（不同 binding）不冲突。
- 可序列化、可跨进程复现。
- 尽量稳定（改行不应导致 ID 大面积变动）。

建议实现（在 `analyze` 阶段就确定）：
- `NodeId = ${filePath}:${block}:${bindingStart}-${bindingEnd}:${name}`
  - `bindingStart/bindingEnd` 取自 Babel AST Node 的 `start/end`（字符偏移）。
  - 若无法获取（例如 template 侧的 ref 字符串），则使用 `kind` + `range` 兜底，但需标记 `tags` 提示“弱稳定”。

### 4.3 IRGraph（graphology 作为底座，但 IR 仍可序列化）
IRGraph 采用“两层结构”：
- 序列化层：`nodes[]`、`edges[]`（稳定输出/测试快照/给外部系统）。
- 算法层：`depGraph`（graphology DirectedGraph），用于高效算法计算。

```ts
import type { DirectedGraph } from 'graphology';

export interface IRGraph {
  framework: Framework
  language: LanguageKind
  filePath?: string

  nodes: IRNode[]
  edges: IREdge[]

  depGraph: DirectedGraph
}
```

> graphology 的 Graph key 会被转字符串，因此 `NodeId`/`EdgeId` 必须保证字符串唯一性（见 design-choices 文档）。

## 5. 图层封装设计（packages/graph 的 API）
### 5.1 Node/Edge attributes 约定
graphology 允许给节点/边挂 attributes，本项目约定：
- node attributes：至少包含 `nodeId/name/kind`，其余信息都以 IRNode 为准（避免双写）。
- edge attributes：至少包含 `relations`（数组或 bitmask）、`spanCount`（用于快速评分）。

```ts
export interface DepNodeAttr {
  id: NodeId
  name: string
  kind: NodeKind
}

export interface DepEdgeAttr {
  relations: RelationType[]
  spanCount: number
}
```

### 5.2 构建 API（幂等、可增量）
```ts
export function createDepGraph(): import('graphology').DirectedGraph;

export function upsertNode(
  g: import('graphology').DirectedGraph,
  node: IRNode,
): void;

export function mergeRelationEdge(
  g: import('graphology').DirectedGraph,
  from: NodeId,
  to: NodeId,
  relation: RelationType,
): void;
```

实现约束（利用 graphology 的 `mergeEdge` 语义，见 mutation 文档）：
- `mergeRelationEdge` 应使用 `g.mergeEdge(from, to, attrs)` 来避免重复边。
- 若同一 (from,to) 出现不同 relation，则把 `relations` 合并去重。

### 5.3 通用算法 API（优先复用标准库）
```ts
export function weaklyConnectedComponents(g: import('graphology').Graph): NodeId[][];
export function stronglyConnectedComponents(g: import('graphology').Graph): NodeId[][];

export function hasCycleInDirectedGraph(g: import('graphology').DirectedGraph): boolean;
export function topologicalSortOrThrow(g: import('graphology').DirectedGraph): NodeId[];

export function subgraphByNodes(
  g: import('graphology').Graph,
  nodes: Iterable<NodeId>,
): import('graphology').Graph;
```

对应实现来源（保证“准确而非猜测”）：
- `graphology-components` 的 `connectedComponents` 与 `stronglyConnectedComponents`：<https://graphology.github.io/standard-library/components.html>。
- `graphology-dag` 的 `hasCycle`、`topologicalSort`：<https://graphology.github.io/standard-library/dag.html>。
- `graphology-operators` 的 `subgraph`：<https://graphology.github.io/standard-library/operators.html>。

### 5.4 VHO 特化算法（必要时自研，但要严格校验前提）
#### 5.4.1 线性链（Linear Chains）
目标：识别 “A -> B -> C -> ...” 的长链，并判断链上哪些节点与 template/style 强相关，从而给出“压平链路/抽取中间层”的建议。

实现建议：
- 在 `depGraph` 上按 `outDegree==1` 且 `inDegree==1` 的约束抽取 maximal path。
- 若要严格复现当前行为，可在 IR 中保留 `usedInTemplate/style` 并按“链中出现 used 节点且其前后存在未 used 节点”触发 warning。

#### 5.4.2 关节点（Cut Vertices）
当前仓库里在有向依赖图上直接做“关节点”，理论前提不成立。正确做法：
- 将依赖图投影成 **无向图**（忽略方向，将 (u->v) 视作 {u,v}），再计算 articulation points。
- 经典算法是 DFS + `tin/low`（O(V+E)），参考：<https://cp-algorithms.com/graph/cutpoints.html>。

此指标在 VHO 中的解释应明确为：
- “无向关联图的结构割点”（更偏向“连接多个团块的关键符号”），而不是“有向依赖的支配关系”。

## 6. core API 设计（IR 生产 + 方案生成）
### 6.1 Public：统一分析入口（替代多处重复实现）
```ts
export interface AnalyzeInput {
  code: string
  framework: Framework
  filePath?: string
  language?: LanguageKind
}

export interface AnalyzeOptions {
  includeStyle?: boolean
  includeTemplate?: boolean
}

export interface AnalyzeOutput {
  ir: IRGraph
  plan: RefactorPlan
  mermaid: string
  vis: unknown
}

export async function analyze(
  input: AnalyzeInput,
  options?: AnalyzeOptions,
): Promise<AnalyzeOutput>;
```

### 6.2 IR 构建：按“块”产出，不在调用方拼装
```ts
export interface IRBuildResult {
  graph: IRGraph
}

export function buildIRFromVueSFC(input: AnalyzeInput): IRBuildResult;
export function buildIRFromReact(input: AnalyzeInput): IRBuildResult;
```

实现落地时，应复用现有 analyzer 的解析能力，但输出统一迁移到 IR：
- Vue template/style 的 used 集合继续由现有 `analyzeTemplate` / `analyzeStyle` 得到，再映射进 IRNode 的 `usedInTemplate/usedInStyle`。
- script 侧从 `NodeCollection.map()` 的结果迁移到 IRNode/IREdge（并补齐 NodeId 唯一性）。

### 6.3 重构方案生成（RefactorPlan）
#### 6.3.1 数据结构
```ts
export type RefactorActionKind
  = | 'extract_composable'
    | 'extract_hook'
    | 'extract_component'
    | 'extract_service'
    | 'break_cycle'
    | 'flatten_chain'
    | 'remove_unused';

export interface RefactorAction {
  id: string
  kind: RefactorActionKind
  title: string
  rationale: string
  confidence: 'low' | 'medium' | 'high'
  risk: 'low' | 'medium' | 'high'
  nodeIds: NodeId[]
  suggestedFilePath?: string
}

export interface RefactorPlan {
  summary: string
  actions: RefactorAction[]
}
```

#### 6.3.2 方案生成算法（基于 IR 的“可执行管线”）
输入：`IRGraph`（含 `depGraph`、used 标记、节点位置）

输出：`RefactorPlan`

步骤必须可解释且可测试：
1) **识别团块（Chunk Candidates）**
   - 用 `graphology-components.connectedComponents` 在无向投影上得到弱连通团块（用于“孤立群”）；
   - 用 `graphology-components.stronglyConnectedComponents` 找强连通分量（用于“循环依赖团块”）；
   - 用自研 `findLinearChains` 找长链。
2) **团块评分**
   - `template/style 关联度`：团块内 `usedInTemplate/style` 节点占比；
   - `副作用密度`：`relations` 中 `set/call` 占比（高则风险高）；
   - `边界复杂度`：对外依赖数、对外暴露数（越少越适合抽取）。
3) **边界计算（决定抽取接口）**
   - 对团块内每个节点 n，遍历 `inNeighbors/outNeighbors`：
     - `externalDeps`：团块内节点依赖的团块外节点（入参候选）；
     - `publicAPI`：团块外节点依赖的团块内节点（返回/暴露候选）。
4) **选择抽取形态**
   - Vue：优先 `extract_composable`，当团块包含强 UI 绑定节点（大量 template 使用）时优先 `extract_component`；
   - React：优先 `extract_hook`，当团块主要为纯函数/服务调用时优先 `extract_service`；
5) **生成 action 列表与顺序**
   - 先 `break_cycle`（强连通分量）；
   - 再 `extract_service` / `flatten_chain`（降低耦合与复杂度）；
   - 最后做 `extract_composable/hook/component`；
   - `remove_unused` 放在最后（避免误删对后续抽取有用的候选节点）。

## 7. 测试与验证策略（保证“准确”）
- IR 快照测试：同 fixtures 输入应得到确定的 `nodes/edges`（NodeId 稳定）与 `usedInTemplate/style` 标记。
- 算法一致性测试：对比当前 `core/src/suggest/*` 的输出与新方案引擎在“最小闭环阶段”的等价性（允许结构更强但语义一致）。
- 标准库依赖测试：对 `graphology-components`、`graphology-dag` 的核心函数做契约测试（例如 `hasCycle`、`topologicalSort` 的 throw 行为，见 DAG 文档示例）。

## 8. 里程碑拆解（与当前待办对齐）
1) IR 最小闭环：迁移现有 `TypedNode + used 集合 + edges` 到 IR，并保证输出一致。
2) graph 模块落地：引入 graphology 与 `graphology-components`/`graphology-dag`，替换 `splitGraph/hasCycle` 等内置实现。
3) 方案生成引擎：在 IR 之上实现 chunk/boundary/interface/action 的稳定管线，替代 `Suggestion` 的弱结构。
4) 生态适配：VSCode/MCP/ESLint/Playground 全部改为只调用 `core.analyze()`，不再复制流程。
